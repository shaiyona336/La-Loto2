// module imp_con::no_rake_lotto {
//     public struct Ticket has key, store {
//         id: sui::object::UID,
//         lottery_id: sui::object::ID,
//         round: u64,
//         start_number: u64,
//         end_number: u64,
//     }

//     public struct LotteryReceipt has key, store {
//         id: sui::object::UID,
//         lottery_id: sui::object::ID,
//         round: u64,
//         prize_pool: sui::balance::Balance<sui::sui::SUI>,
//         winning_number: u64,
//         prize_claimed: bool,
//     }

//     public struct Lottery has key {
//         id: sui::object::UID,
//         current_pool: sui::balance::Balance<sui::sui::SUI>,
//         current_round: u64,
//         last_draw_timestamp: u64,
//         is_open: bool,
//     }

//     public struct RoundCompleted has copy, drop { round: u64, winning_number: u64, prize_pool: u64 }
//     public struct PrizeClaimed has copy, drop { winner: address, prize: u64, round: u64 }

//     const E_LOTTERY_IS_EMPTY: u64 = 0;
//     const E_TOO_EARLY_TO_DRAW: u64 = 1;
//     const E_LOTTERY_IS_CLOSED: u64 = 2;
//     const E_NOT_WINNING_TICKET: u64 = 3;
//     const E_PRIZE_ALREADY_CLAIMED: u64 = 4;
//     const E_WRONG_LOTTERY_ROUND: u64 = 5;

//     // This is a new, private helper function containing the creation logic.
//     fun do_create_lottery(ctx: &mut sui::tx_context::TxContext) {
//         let lottery = Lottery {
//             id: sui::object::new(ctx),
//             current_pool: sui::balance::zero(),
//             current_round: 1,
//             last_draw_timestamp: 0,
//             is_open: true,
//         };
//         sui::transfer::share_object(lottery);
//     }
    
//     /// The real init function, which now just calls the helper.
//     fun init(ctx: &mut sui::tx_context::TxContext) {
//         do_create_lottery(ctx);
//     }

//     /// The test-only init function, which also calls the helper.
//     public(package) fun test_init(ctx: &mut sui::tx_context::TxContext) {
//         do_create_lottery(ctx);
//     }

//     public fun enter(lottery: &mut Lottery, ticket_coin: sui::coin::Coin<sui::sui::SUI>, ctx: &mut sui::tx_context::TxContext) {
//         assert!(lottery.is_open, E_LOTTERY_IS_CLOSED);
//         let deposit_value = sui::coin::value(&ticket_coin);
//         let deposit_balance = sui::coin::into_balance(ticket_coin);
//         sui::balance::join(&mut lottery.current_pool, deposit_balance);
//         let pool_value_after_join = sui::balance::value(&lottery.current_pool);
//         let ticket = Ticket {
//             id: sui::object::new(ctx),
//             lottery_id: sui::object::id(lottery),
//             round: lottery.current_round,
//             start_number: pool_value_after_join - deposit_value + 1,
//             end_number: pool_value_after_join,
//         };
//         sui::transfer::transfer(ticket, sui::tx_context::sender(ctx));
//     }

//     entry fun draw_winner(
//         lottery: &mut Lottery,
//         winning_number: u64,
//         current_timestamp: u64,
//         ctx: &mut sui::tx_context::TxContext
//     ) {
//         assert!(current_timestamp >= lottery.last_draw_timestamp + 60_000, E_TOO_EARLY_TO_DRAW);
//         let total_pool_value = sui::balance::value(&lottery.current_pool);
//         assert!(total_pool_value > 0, E_LOTTERY_IS_EMPTY);
//         assert!(winning_number > 0 && winning_number <= total_pool_value, 0); 

//         lottery.is_open = false;

//         let prize_balance = sui::balance::split(&mut lottery.current_pool, total_pool_value);
//         let receipt = LotteryReceipt {
//             id: sui::object::new(ctx),
//             lottery_id: sui::object::id(lottery),
//             round: lottery.current_round,
//             prize_pool: prize_balance,
//             winning_number: winning_number,
//             prize_claimed: false,
//         };
//         sui::dynamic_field::add(&mut lottery.id, lottery.current_round, receipt);
//         sui::event::emit(RoundCompleted { round: lottery.current_round, winning_number, prize_pool: total_pool_value });
        
//         lottery.current_round = lottery.current_round + 1;
//         lottery.last_draw_timestamp = current_timestamp;
//         lottery.is_open = true;
//     }

//     entry fun claim_prize(lottery: &mut Lottery, winning_ticket: Ticket, ctx: &mut sui::tx_context::TxContext) {
//         let round = winning_ticket.round;
//         let receipt: &mut LotteryReceipt = sui::dynamic_field::borrow_mut(&mut lottery.id, round);
//         assert!(!receipt.prize_claimed, E_PRIZE_ALREADY_CLAIMED);
//         assert!(winning_ticket.round == receipt.round, E_WRONG_LOTTERY_ROUND);
//         assert!(receipt.winning_number >= winning_ticket.start_number && receipt.winning_number <= winning_ticket.end_number, E_NOT_WINNING_TICKET);
//         let winner_address = sui::tx_context::sender(ctx);
//         let prize_amount = sui::balance::value(&receipt.prize_pool);
//         let prize_coin = sui::coin::from_balance(sui::balance::split(&mut receipt.prize_pool, prize_amount), ctx);
//         sui::transfer::public_transfer(prize_coin, winner_address);
//         receipt.prize_claimed = true;
//         sui::event::emit(PrizeClaimed { winner: winner_address, prize: prize_amount, round: receipt.round });
//         let Ticket { id, lottery_id: _, round: _, start_number: _, end_number: _ } = winning_ticket;
//         sui::object::delete(id);
//     }
    
//     #[test_only]
//     public fun current_pool_value(lottery: &Lottery): u64 { sui::balance::value(&lottery.current_pool) }
//     #[test_only]
//     public fun current_round(lottery: &Lottery): u64 { lottery.current_round }
//     #[test_only]
//     public fun is_open(lottery: &Lottery): bool { lottery.is_open }
//     #[test_only]
//     public fun get_receipt_winning_number(lottery: &Lottery, round: u64): u64 {
//         let receipt: &LotteryReceipt = sui::dynamic_field::borrow(&lottery.id, round);
//         receipt.winning_number
//     }
// }